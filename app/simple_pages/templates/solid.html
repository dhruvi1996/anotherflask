{% extends "base.html" %}
{% block content %}
    <img src="{{ url_for('static', filename='images/sp1.png') }}" xmlns="http://www.w3.org/1999/html" class="img-fluid "
         alt="OOPbanner">
    <div class="row align-items-center">
        <div class="col-6 py-4">
            <h4 class="neonblue" mt-3><u>What are SOLID principles??</u></h4>
            <p><span class="fs-4">S</span>olid is a mnemonic abbreviation for a set of design principles created for
                software
                development in object-oriented languages. The principles in SOLID are intended to foster simpler, more
                robust and updatable code from software developers.
                The principle of SOLID coding is an acronym originated by Robert C. Martin, and it stands for five
                different conventions of coding.
                If you follow, these principles you can improve the reliability of your code by working on its structure
                and its logical consistency.
            </p>
        </div>
        <div class="col-6 py-4">
            <p class="fs-20">
            <ul>
                <li>The Single-Responsibility Principle (SRP)</li>
                <li>The Open-Closed Principle (OCP)</li>
                <li>The Liskov Substitution Principle (LSP)</li>
                <li>The Interface Segregation Principle (ISP)</li>
                <li>The Dependency inversion Principle (DIP)</li>
            </ul>
            </p>

        </div>
    </div>
    <div class="row align-items-center">
        <h1 class="b1 pt-3"></h1>
        <div class="col-6 pb-4">
            <h4 class="neonblue"><u>The Single-Responsibility Principle (SRP)</u></h4>
            <p>
                <strong>“A class should have one, and only one, reason to change”</strong>
                In other words, every component of your code (in general a class, but also a function) should have one
                and only one responsibility. As a consequence of that, there should be only a reason to change it.
                Too often you see a piece of code that takes care of an entire process all at once. I.e., A function
                that loads data, modifies and, plots them, all before returning its result.

            </p>
        </div>
        <div class="col-6 pb-5">
            <img src="{{ url_for('static', filename='images/sp 1part.png') }}"
                 class="img-fluid py-2 "
                 alt="o">
        </div>
    </div>
    <div class="row align-items-center">
        <h1 class="b1 pt-5"></h1>
        <div class="col-6 pb-4">

            <h4 class="neonblue"><u>The Open-Closed Principle (OCP)</u></h4>
            <p>
                <strong>“Software entities … should be open for extension but closed for modification”.</strong>
                In other words: You should not need to modify the code you have already written to accommodate new
                functionality, but simply add what you now need.
                This does not mean that you cannot change your code when the code premises needs to be modified, but
                that if you need to add new functions similar to the one present, you should not require to change other
                parts of the code.Implementing class as an abstract class and implement methods as abstract methods, it
                promotes the use of interfaces to enable you to adapt the functionality of your application without
                changing the existing code. This enables loose coupling.
            </p>
        </div>
        <div class="col-6 pb-4">
            <img src="{{ url_for('static', filename='images/open.png') }}"
                 class="img-fluid"
                 alt="l">
            <p class="fs-20">
            </p>
        </div>
    </div>
    <div class="row align-items-center">
        <h1 class="b1 pt-5"></h1>
        <div class="col-6 pb-4">
            <h4 class="neonblue"><u>The Liskov Substitution Principle (LSP)</u></h4>
            <p>
                <strong>Objects in a program should be replaceable with instances of their subtypes without altering the
                    correctness of that program.”</strong>
                The Liskov substitution principle (LSP) is a specific definition of a subtyping relation created by
                Barbara Liskov and Jeannette Wing. The principle says that any class must be directly replaceable by any
                of its subclasses without error.
                In other words, each subclass must maintain all behavior from the base class along with any new
                behaviors unique to the subclass. The child class must be able to process all the same requests and
                complete all the same tasks as its parent class.</p>
            <p>
                “Functions that use pointers or references to base classes must be able to use objects of derived
                classes without knowing it”

            </p>
        </div>
        <div class="col-6 pb-4">
            <img src="{{ url_for('static', filename='images/lp sp.png') }}"
                 class="img-fluid"
                 alt="i">
        </div>
    </div>

    <div class="row align-items-center">
        <h1 class="b1 pt-5"></h1>
        <div class="col-6 pb-4">
            <h4 class="neonblue" mt-1><u>The Interface Segregation Principle (ISP)</u></h4>
            <p>
                <strong>“Many client-specific interfaces are better than one general-purpose interface”.</strong>
                In the contest of classes, an interface is considered, all the methods and properties “exposed”, thus,
                everything that a user can interact with that belongs to that class.
                In this sense, the IS principles tell us that a class should only have the interface needed (SRP) and
                avoid methods that won’t work or that have no reason to be part of that class.
                This problem arises, primarily, when, a subclass inherits methods from a base class that it does not
                need.
            </p>
        </div>
        <div class="col-6 pb-4">
        </div>
    </div>
    <div class="row align-items-center">
        <h1 class="b1 pt-5"></h1>
        <div class="col-6 pb-4">
            <h4 class="neonblue" mt-1><u>The Dependency inversion Principle (DIP)</u></h4>
            <p>
                <strong>Abstractions should not depend on details. Details should depend on abstraction. High-level
                    modules should not depend on low-level modules. Both should depend on abstractions”</strong>
                The dependency inversion principle (DIP) has two parts:

                High-level modules should not depend on low-level modules. Instead, both should depend on abstractions
                (interfaces)
                Abstractions should not depend on details. Details (like concrete implementations) should depend on
                abstractions.
                The advantage of this part of DIP is that decoupled programs require less work to change. Webs of
                dependencies across your program mean that a single change can affect many separate parts.
            </p>
        </div>
        <div class="col-6 pb-4">
            <img src="{{ url_for('static', filename='images/last solid.png .png') }}"
                 class="img-fluid"
                 alt="i">
        </div>
    </div>

    <h1 class="b2 pt-5"></h1>
    <h4 class="neonblue mt-2"><u>Design Patters : </u></h4>️ ️
    <div class="row align-items-start">
        <div class="col-8">
            <p>
                <span class="fs-3">D</span>esign Patterns is the most essential part of Software Engineering, as they
                provide the general repeatable solution to a commonly occurring problem in software design. They usually
                represent some of the best practices adopted by experienced object-oriented software developers.
                You can’t just find a pattern and copy it into your program, the way you can with off-the-shelf
                functions or
                libraries. The pattern is not a specific piece of code, but a general concept for solving a particular
                problem. You can follow the pattern details and implement a solution that suits the realities of your
                own
                program.Design patterns represent the best practices used by experienced object-oriented software
                developers. Design patterns are solutions to general problems that software developers faced during
                software development. These solutions were obtained by trial and error by numerous software developers
                over quite a substantial period of time. Design patterns provide a standard terminology and are specific
                to particular scenario. For example, a singleton design pattern signifies use of single object so all
                developers familiar with single design pattern will make use of single object and they can tell each
                other that program is following a singleton pattern.
            </p>
        </div>
        <div class="col-4 py-4">
            <img src="{{ url_for('static', filename='images/types_of_design_patterns_in_java.png') }}"
                 class="img-fluid"
                 alt="designpat" id="zoomA">
        </div>
    </div>
    <div class="row justify-content-center py-4">
        <div class="col-2"></div>
        <div class="col-8">
        </div>
        <div class="col-2"></div>
    </div>
    <h1 class="b1"></h1>
    <div class="row align-items-start">
        <div class="col-8">
            <h4 class="neonblue mt-4"><u>Behavioral Patterns: </u></h4>️ ️
            <p>
                <span class="fs-3">B</span>ehavioral patterns help to define how the objects should communicate and
                interact with one another. Some of the examples of behavioural patterns are - Command pattern, Iterator
                pattern, Observer pattern, Strategy pattern, etc.
                These patterns characterize complex control flow that is difficult to follow at run-time. They shift
                your
                focus away from the flow of control to let you concentrate just on the way objects are interconnected.
                Behavioral class patterns use inheritance to distribute behavior between classes.Artificial intelligence
                pattern for combining disparate sources of data Chain of responsibility Avoid coupling the sender of a
                request to its receiver by giving more than one object a chance to handle the request. Chain the
                receiving objects and pass the request along the chain until an object handles it. Command Encapsulate a
                request as an object, thereby allowing for the parameterization of clients with different requests, and
                the queuing or logging of requests. It also allows for the support of undoable operations. Interpreter
                Given a language, define a representation for its grammar along with an interpreter that uses the
                representation to interpret sentences in the language. Iterator Provide a way to access the elements of
                an aggregate object sequentially without exposing its underlying representation.
                A subclass fleshes out the algorithm by defining the abstract operations. The other
                behavioral class pattern is Interpreter pattern, which represents a grammar as a class hierarchy and
                implements an interpreter as an operation on instances of these classes.
            </p>
        </div>
        <div class="col-4 py-4">
            <img src="{{ url_for('static', filename='images/Behavioral-Design-Patterns copy.png') }}"
                 class="img-fluid"
                 alt="beh">
        </div>
    </div>
    <h1 class="b1"></h1>
    <div class="row align-items-start">
        <div class="col-8">
            <h4 class="neonblue mt-4"><u>Creational Patterns: </u></h4>️ ️
            <p>
                <span class="fs-3">C</span>reational patterns provide freedom of choice between creating objects by
                hiding the logic. The objects constructed are decoupled from the implemented system. Some of the
                examples of creational patterns are - Factory design pattern, Builder design, Prototype design,
                Singleton design, Abstract Factory design.
                Creational patterns support the creation of objects in a system. Creational patterns allow objects to be
                created in a system without having to identify a specific class type in the code, so you do not have to
                write large, complex code to instantiate an object. It does this by having the subclass of the class
                create the objects. However, this can limit the type or number of objects that can be created within a
                system.
            </p>
        </div>
        <div class="col-4 py-4">
            <img src="{{ url_for('static', filename='images/pic3-768x558.jpeg') }}"
                 class="img-fluid"
                 alt="createpat">
        </div>
    </div>
    <h1 class="b1"></h1>
    <div class="row align-items-start">
        <div class="col-8">
            <h4 class="neonblue mt-4"><u>Structural Patterns: </u></h4>️ ️
            <p>
                <span class="fs-3">S</span>tructural patterns help in defining how the structures of classes and objects
                should be like for defining the composition between classes, interfaces and objects. Some of the
                examples of structural patterns are - Adaptor design, Facade design, Decorator design, proxy design etc.
                Structural design patterns are about organizing different classes and objects to form larger structures
                and provide new functionality while keeping these structures flexible and efficient. Mostly they use
                Inheritance to compose all the interfaces. It also identifies the relationships which led to the
                simplification of the structure.
                Structural patterns are concerned with how classes and objects are composed to form larger structures.
                Structural class patterns use inheritance to compose interfaces or implementations. As a simple example,
                consider how multiple inheritance mixes two or more classes into one. The result is a class that
                combines the properties of its parent classes. This pattern is particularly useful for making
                independently developed class libraries work together.
            </p>
        </div>
        <div class="col-4">
            <img src="{{ url_for('static', filename='images/structural-Design-pattern-768x471.jpeg') }}"
                 class="img-fluid py-3"
                 alt="structpattern">
        </div>
    </div>
    <h1 class="b1 pt-5"></h1>
    <p class="fs-14">Resources:
    <ul class="fs-14">
        <li>
            <a href="https://towardsdatascience.com/solid-coding-in-python-1281392a6a94"
               class="card-link darkgrey" target="_blank">SOLID</a>
        </li>
        <li>
            <a href="https://www.educative.io/blog/solid-principles-oop-c-sharp"
               class="card-link darkgrey" target="_blank">SOLID principles</a>
        </li>
        <li>
            <a href="https://www.interviewbit.com/design-patterns-interview-questions/"
               class="card-link darkgrey" target="_blank">Design & Structural</a>
        </li>
        <li>
            <a href="https://www.geeksforgeeks.org/python-design-patterns/"
               class="card-link darkgrey" target="_blank">Design Patterns</a>
        </li>
    </ul>
    </div>
    </div>
{% endblock %}